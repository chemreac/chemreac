#!/usr/bin/env python
# -*- coding: utf-8 -*-

br"""
Equilibrium
-----------

:download:`examples/equilibrium.py` demonstrates how
scaling can be used together with tolerances to achieve
desired accuracy from the numerical integration.

We will consider the transient towards an equilibrium
for a dimerization:

.. math ::

    A + &B &\overset{k_f}{\underset{k_b}{\rightleftharpoons}}  C

The analytic solution is (its derivation is left as an exercise):

.. math::

    A(t) &= A_0 - x(t) \\
    B(t) &= B_0 - x(t) \\
    C(t) &= C_0 + x(t) \\
    x(t) &= \frac{(U-b)(U+b)(e^{Ut}-1)}{2k_f(Ue^{Ut} + U - qe^{Ut} +  q)} \\

where

.. math::

    U    &= \sqrt{A^2k_f^2 + 2ABk_f^2 - 2Ak_bk_f + B^2k_f^2 -
                2Bk_bk_f + 4Ck_bk_f + k_b^2} \\
    q    &= Ak_f + Bk_f - k_b


::

 $ python equilibrium.py --help

.. exec::
   echo "::\\n\\n"
   python examples/examples/equilibrium.py --help | sed "s/^/   /"


Here is an example generated by:

::

 $ python equilibrium.py --plot --savefig equilibrium.png


.. image:: ../_generated/equilibrium.png

"""

from __future__ import (absolute_import, division,
                        print_function, unicode_literals)
from future.builtins import *

import argh
import numpy as np

from chemreac import ReactionDiffusion
from chemreac.integrate import run
from chemreac.util.analysis import solver_linear_error
from chemreac.util.plotting import (
    save_and_or_show_plot, plot_solver_linear_error,
    plot_solver_linear_excess_error
)


def _algebraic_sigmoid(x, power, limit):
    # Avoid overflow in exp()
    return x/((x/limit)**power+1)**(-1/power)


def analytic_x(t, A, B, C, kf, kb, _exp=np.exp):
    """
    Analytic solution to the dimeriztion reaction:
        A + B <=> C; (K = kf/kb)
    """
    q = -A*kf - B*kf - kb
    U = (A**2*kf**2 - 2*A*B*kf**2 + 2*A*kb*kf + B**2*kf**2 +
         2*B*kb*kf + 4*C*kb*kf + kb**2)**0.5
    expUt = _exp(U*t)
    return -(U - q)*(U + q)*(1 - 1/expUt)/(2*kf*(U + U/expUt - q + q/expUt))


def _get_Cref(t, y0, k, use_mpmath=True):
    """ convenience function for generating reference trajectory """
    if use_mpmath:
        import mpmath as mp
        mp.mp.dps = 30  # number of significant figures
        y0 = [mp.mpf(_) for _ in y0]
        k = [mp.mpf(_) for _ in k]
        _exp = np.vectorize(mp.exp)
    else:
        _exp = lambda x: np.exp(_algebraic_sigmoid(x, 8, 350))
    A, B, C = y0
    kf, kb = k
    x = analytic_x(t, A, B, C, kf, kb, _exp).reshape((t.size, 1))
    dy = np.hstack((-x, -x, x))
    res = y0 + dy
    if use_mpmath:
        res = np.array(res, dtype=np.float64)
    return res


def integrate_rd(
        tend=1.9, A0=4.2, B0=3.1, C0=1.4, nt=100, t0=0.0,
        kf=0.9, kb=0.23, atol='1e-7,1e-6,1e-5', rtol='1e-6',
        logy=False, logt=False, num_jac=False, plot=False, savefig='None',
        splitplots=False, plotlogy=False, plotlogt=False,
        scale_err=1.0, verbose=False):
    """
    Runs the integration and (optionally) plots:

    - Individual concentrations as function of time
    - Reaction Quotient vs. time (with equilibrium constant as reference)
    - Numerical error commited (with tolerance span plotted)
    - Excess error committed (deviation outside tolerance span)
    """

    rtol = float(rtol)
    atol = list(map(float, atol.split(',')))
    if len(atol) == 1:
        atol = atol[0]

    rd = ReactionDiffusion(3, [[0, 1], [2]], [[2], [0, 1]], [kf, kb],
                           logy=logy, logt=logt)

    y0 = np.array([A0, B0, C0])
    if plotlogt:
        tout = np.logspace(np.log10(t0), np.log10(tend), nt)
    else:
        tout = np.linspace(t0, tend, nt)
    integr = run(rd, y0, tout, atol=atol, rtol=rtol, with_jacobian=not num_jac)
    Cout, yout, info = integr.Cout, integr.yout, integr.info
    try:
        import mpmath
    except ImportError:
        use_mpmath = False
    else:
        use_mpmath = True
    Cref = _get_Cref(tout - tout[0], y0, [kf, kb],
                     use_mpmath).reshape((nt, 1, 3))
    if verbose:
        print(info)

    if plot:
        npltcols = 3 if splitplots else 1
        import matplotlib.pyplot as plt
        fig = plt.figure(figsize=(18 if splitplots else 6, 10))

        def subplot(row=0, idx=0, adapt_yscale=True, adapt_xscale=True,
                    span_all_x=False):
            offset = idx if splitplots else 0
            ax = plt.subplot(4, 1 if span_all_x else npltcols,
                             1 + row*npltcols + offset)
            if adapt_yscale and plotlogy:
                ax.set_yscale('symlog')
            if adapt_xscale and plotlogt:
                ax.set_xscale('log')
            return ax

        c = 'rgb'
        for i, l in enumerate('ABC'):
            # Plot solution trajectory for i:th species
            ax_sol = subplot(0, i)
            ax_sol.plot(tout, Cout[:, 0, i], label=l, color=c[i])

            if splitplots:
                # Plot relative error
                ax_relerr = subplot(1, 1)
                ax_relerr.plot(tout, Cout[:, 0, i]/Cref[:, 0, i] - 1.0,
                               label=l, color=c[i])
                # Plot absolute error
                ax_abserr = subplot(1, 2)
                ax_abserr.plot(tout, Cout[:, 0, i]-Cref[:, 0, i],
                               label=l, color=c[i])

            # Plot absolute error
            linE = Cout[:, 0, i] - Cref[:, 0, i]
            try:
                atol_i = atol[i]
            except:
                atol_i = atol
            wtol_i = atol_i + rtol*Cout[:, 0, i]

            if np.any(np.abs(linE/wtol_i) > 1000):
                # Plot true curve in first plot when deviation is large enough
                # to be seen visually
                ax_sol.plot(tout, Cref[:, 0, i], label='true '+l,
                            color=c[i], ls='--')

            ax_err = subplot(2, i)
            plot_solver_linear_error(integr, Cref, ax_err, si=i,
                                     scale_err=1/wtol_i, color=c[i])
            ax_excess = subplot(3, i, adapt_yscale=False)
            plot_solver_linear_excess_error(integr, Cref, ax_excess,
                                            si=i, color=c[i], label=l)

        # Plot Reaction Quotient vs time
        ax_q = subplot(1, span_all_x=False)
        Qnum = Cout[:, 0, 2]/(Cout[:, 0, 0]*Cout[:, 0, 1])
        Qref = Cref[:, 0, 2]/(Cref[:, 0, 0]*Cref[:, 0, 1])
        ax_q.plot(tout, Qnum, label='Q', color=c[i])
        if np.any(np.abs(Qnum/Qref-1) > 0.01):
            # If more than 1% error in Q, plot the reference curve too
            ax_q.plot(tout, Qref, '--', label='Qref', color=c[i])
        # Plot the
        ax_q.plot((tout[0], tout[-1]), [kf/kb]*2, '--k', label='K')
        plt.xlabel('t')
        plt.ylabel('[C]/([A][B])')
        plt.title("Transient towards equilibrium")
        plt.legend(loc='best')

        for i in range(npltcols):
            subplot(0, i, adapt_yscale=False)
            plt.title('Concentration vs. time')
            plt.legend(loc='best', prop={'size': 11})
            plt.xlabel('t')
            plt.ylabel('[X]')

            subplot(2, i, adapt_yscale=False)
            plt.title('Absolute error in [{}](t) / wtol'.format('ABC'[i]))
            plt.legend(loc='best')
            plt.xlabel('t')
            ttl = '|E_i[{0}]|/(atol_i + rtol*(y0_i+yf_i)/2'
            plt.ylabel(ttl.format('ABC'[i]))
            plt.tight_layout()

            subplot(3, i, adapt_yscale=False)
            ttl = 'Excess error in [{}](t) / solver linear error span'
            plt.title(ttl.format(
                'ABC'[i]))
            plt.legend(loc='best')
            plt.xlabel('t')
            plt.ylabel('|E_excess[{0}]| / e_span'.format('ABC'[i]))

        plt.tight_layout()
        save_and_or_show_plot(savefig=savefig)

    return yout, Cref, rd, info


if __name__ == '__main__':
    argh.dispatch_command(integrate_rd, output_file=None)
